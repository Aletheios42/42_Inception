## Define el usuario del sistema operativo bajo el cual se ejecutarán
## los procesos worker de Nginx (en este caso, nginx).
## Ejecuta 
## docker exec -it nginx ps aux
## Mira el usuario de los procesos workers
user  nginx;
## Ejecuta,
## docker exec -it nginx ps aux
## Cuenta el numero de workers que ves
worker_processes  1;

## Define el numero de conexiones por worker
## Esta puesto 1024 como valor standard
## Históricamente coincide con el valor por defecto de ulimit -n 
## (máximo de descriptores de archivo abiertos por proceso).
events {
    worker_connections  1024;
}

## Este bloque maneja todo lo que tiene que ver con el protocolo de aplicación HTTP
http {
    ## Incluye todos las extensiones reconocidas, Ejecuta:
    ## docker exec nginx cat /etc/nginx/mime.types
    include       mime.types;
    ## Tipo MIME predeterminado cuando la respuesta no especifica Content-Type
    ## Para ver cabeceras HTTP con estructura RFC, usar:
    ## curl -I https://www.google.com/
    default_type  application/octet-stream;

## Bloque que define un servidor virtual: configuración de puertos, dominios y comportamiento específico para este host.
    server {
        ## Escucha conexiones IPv4 en el puerto 443 con TLS activado
        listen 443 ssl;

        ## Escucha conexiones IPv6 en el puerto 443 con TLS activado
        ## [::] representa todas las interfaces IPv6, análogo a 0.0.0.0 en IPv4
        listen [::]:443 ssl;

        ## Ejemplo de petición HTTP/1.1 enviada por el cliente (navegador):

        ##GET /index.php HTTP/1.1
        ##Host: www.alepinto.42.fr
        ##User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36
        ##Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
        ##Accept-Language: es-ES,es;q=0.9,en;q=0.8
        ##Accept-Encoding: gzip, deflate, br
        ##Connection: keep-alive
        ##Upgrade-Insecure-Requests: 1

        ## `server_name` define los nombres de host para comparar con la cabecera `Host` de la petición HTTP
        ## Habilitar localhost en server_name durante desarrollo es buena práctica para facilitar pruebas locales sin DNS ni certificados externos.
        server_name www.alepinto.42.fr alepinto.42.fr;

        ## Explicare el TLS.12 porque es mas ilustrativo
        ## Ya que el TLS.1.3 es una optimizacion 
        ## protocolo TSL 1.2
        ##Cliente (C)                           Servidor (S)
        ##-----------------------------------------------------
        ##ClientHello ------------------------> 
        ##- Versión TLS soportada
        ##- Suites de cifrado
        ##- Nonce aleatorio Rc
        ##- SNI: nombre del servidor
        ##
        ##<---------------- ServerHello
        ##- Versión TLS seleccionada
        ##- Suite de cifrado escogida
        ##- Nonce aleatorio Rs
        ##
        ##<---------------- Certificate
        ##- Certificado X.509 (clave pública Ks_pub)
        ##
        ##<---------------- CertificateVerify
        ##- Firma con Ks_priv
        ##
        ##<---------------- Finished
        ##- Mensaje de finalización servidor
        ##
        ##Finished ------------------------> 
        ##- Mensaje de finalización cliente
        ##
        ##-----------------------------------------
        ##Claves simétricas derivadas de Rc, Rs y parámetros clave,
        ##usadas para cifrar la comunicación posterior.
        
        ## Certificado X.509 del servidor (incluye clave pública)
        ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
        ## Clave privada asociada al certificado
        ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
        ## Versión mínima de TLS aceptada
        ssl_protocols TLSv1.3;

        ## Archivo predeterminado servido cuando no se especifica archivo en la URL
        index index.php;

        ## Directorio raíz desde el que Nginx servirá los archivos solicitados (Nuestro Proyecto Php)
        ## Para ver el contenido utiliza
        ## docker exec -it nginx ls -l /var/www/html/
        root /var/www/html;

        ## Esta directiva procesa las peticiones cuyos paths en la URL
        ## terminan en ".php", incluyendo casos con una barra al final o sin ella.
        ##
        ## El regex `[^\ /]\.php(/|$)` se interpreta como:
        ## - `[^\ /]`: cualquier carácter que no sea '/' antes de ".php"
        ## - `\.php`: la extensión literal ".php"
        ## - `(/|$)`: seguido por una barra '/' o el final de la cadena
        ##
        ## Esto asegura que se capturan archivos PHP directamente solicitados, 
        ## pero no rutas que terminen en directorios o con ".php" dentro de segmentos.
        location ~ [^/]\.php(/|$) {
            ## Verifica que el archivo PHP solicitado exista en el sistema de archivos
            try_files $uri =404;

            ## Envía la petición al servidor FastCGI (PHP-FPM) escuchando en el host 'wordpress' puerto 9000
            fastcgi_pass wordpress:9000;

            ## Incluye los parámetros FastCGI estándar necesarios para la correcta ejecución de PHP
            ## Ejecuta: docker exec -it nginx cat /etc/nginx/fastcgi_params
            include fastcgi_params;

            ## Define la ruta absoluta del script PHP que debe ejecutar PHP-FPM
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        }


        ## Añadido para conectar con mi app de node
        location /cv/ {
            proxy_pass http://cv_server:7777/;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        ## Para que funcione tambien sin barra
        location = /cv {
            return 301 /cv/;
        }
    }
}
